Напишите функцию, которая будет выводить по неубыванию все ключи от 
L
L до 
R
R включительно в заданном бинарном дереве поиска.

Ключи в дереве могут повторяться. Решение должно иметь сложность 
O
(
h
+
k
)
O(h+k), где 
h
h –— глубина дерева, 
k
k — число элементов в ответе.

В данной задаче если в узле содержится ключ 
x
x, то другие ключи, равные 
x
x, могут быть как в правом, так и в левом поддереве данного узла. (Дерево строил стажёр, так что ничего страшного).

image

Используйте заготовки кода для данной задачи, расположенные по ссылкам:

c++
Java
js
Python
C#
go
Kotlin
Swift
Формат ввода
На вход функции подаётся корень дерева и искомый ключ. Число вершин в дереве не превосходит 
1
0
5
10 
5
 . Ключи – натуральные числа, не превосходящие 
1
0
9
10 
9
 . Гарантируется, что 
L
≤
R
L≤R.

В итоговом решении не надо определять свою структуру / свой класс, описывающий вершину дерева.

Вы можете ознакомиться с инструкцией по работе с Make на платформе в разделе "Начало", тема «Введение в алгоритмы», урок «Оптимизация ввода и вывода»

Формат вывода
Функция должна напечатать по неубыванию все ключи от 
L
L до 
R
R по одному в строке.
