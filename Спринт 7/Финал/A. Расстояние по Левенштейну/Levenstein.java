/*
 * Форматирование кода сделано автоматически в Intellij Idea.
 * Описание алгоритма
 * создаём двумерный массив dp[][]
 * количество строк - равно количеству символов первой строки (s) + 1 (теперь это не так,
 * теперь только 2).
 * количество столбцов - равно количеству символов второй строки (t) + 1
 *
 * АЛГОРИТМ ИСПРАВЛЕН, ЧТОБЫ В dp хранилось только две строки.
 *
 * dp[i][j] содержит расстояние Левенштейна (т.е. минимальное количество
 * атомарных операций (вставка/удаление/замена)) чтобы получить из строки
 * s[1..i] (c 1 до i-символа включительно (индексация с единицы))
 * строку t[1..j] (c 1 до j-символа включительно (индексация с единицы)).
 *
 * Заполняем первый столбец dp[i][0] = i, где i от 0 до s.length() включительно.
 * это означает, что чтобы получить 0 символов строки t, из строки s[1..i] (индексация с 1)
 * нужно удалить i символов строки s[1..i].
 *
 * Заполняем первую строку dp[0][i] = i, где i от 0 до t.length() включительно.
 * это означает, что из 0 символов строки s, чтобы получить строку t[1..i] (индексация с 1)
 * нужно вставить i символов.
 *
 * Идём по строкам. В каждой строке идём по столбцам. Заполняем dp[i][j].
 * Если s[i] == t[j] (индексация с 1), то значит ничего делать не надо, и расстояние
 * Левенштейна остаётся тем же самым, что было при предыдущих символах строк s и t, т.е.
 * dp[i][j] = d[i - 1][j - 1].
 *
 * Однако, если s[i] != t[j] (индексация с 1), то значит, количество атомарных операций увеличится
 * на 1 (надо будет либо удалить символ из строки s, либо вставить символ в строку s,
 * либо заменить символ в строке s), при этом нам надо поддерживать минимальное количество
 * атомарных операций, а значит 1 надо добавить к минимуму из
 * dp[i-j][j - 1], dp[i][j - 1] и dp[i - 1][j]
 *
 * dp[i - 1][j - 1] - когда мы получали из i-1 символов строки s j-1 символов строки t, в этом случае добавление
 * единицы будет означать замену символа в строке s.
 *
 * dp[i - 1][j] - когда мы получали из i-1 символов строки s j символов строки t, в этом случае добавление
 * единицы будет означать удаления символа из строки s (в dp[i - 1][j] мы уже получили из i-1
 * символов строки s j символов строки t, а значит i-ый символ строки s лишний, и его надо удалить).
 *
 * dp[i][j - 1] - когда мы получали из i символов строки s j-1 символов строки s, в этом случае добавление
 * единицы будет означать вставку символа в строку s (в dp[i][j - 1] мы уже получили из i символов
 * строки s j-1 символов строки t, а значит при обработке j-символа строки t, нам надо вставить
 * этот символ в строку s)
 *
 * В итоге в dp[s.length()][t.length()] - будет ответ.
 *
 * Алгоритмическая сложность: O(n * m), где n - длина строки s, m - длина строки t.
 * Мы делаем цикл по n, а внутри него цикл по m.
 *
 * Пространственная сложность: O(2 * m) = O(m), где m - длина строки t.
 * Мы делаем двумерный массив dp[2][m + 1]
 * */

import java.util.*;

public class Levenstein {
    private static final int DP_ROWS_COUNT = 2;//храним только две строки

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.nextLine();
        String t = scanner.nextLine();

        int[][] dp = new int[DP_ROWS_COUNT][t.length() + 1];

        for (int i = 0; i <= t.length(); i++) {
            dp[0][i] = i;
        }

        int prevRow = 0;
        int currentRow = 1;

        for (int i = 1; i <= s.length(); i++) {
            dp[prevRow][0] = i - 1;//чтобы получить из i - 1 символов строки s 0 символов строки t нужно удалить i - 1 символов
            dp[currentRow][0] = i;//чтобы получить из i символов строки s 0 символов строки t нужно удалить i символов
            for (int j = 1; j <= t.length(); j++) {
                if (s.charAt(i - 1) == t.charAt(j - 1)) {
                    dp[currentRow][j] = dp[prevRow][j - 1];
                } else {
                    dp[currentRow][j] = Math.min(Math.min(dp[prevRow][j], dp[currentRow][j - 1]), dp[prevRow][j - 1]) + 1;
                }
            }
            //меняем currentRow и prevRow местами
            prevRow = currentRow;
            currentRow = 1 - currentRow;
        }

        //после последней итерации currentRow стала prevRow
        System.out.println(dp[prevRow][dp[0].length - 1]);
    }
}
